## 2. 搜索结果处理

搜索的结果可以按照用户指定的方式去处理或展示。

### 2.1 排序（与查询 `query` 是同一级别）

Elasticsearch 默认是根据相关度算分（`_score`）来排序，但也支持自定义方式对搜索结果排序。可以排序的字段类型有：`keyword` 类型、数值类型、地理坐标类型、日期类型等

#### 2.1.1 普通字段排序

`keyword`、数值、日期类型排序的语法基本一致

**语法：**

```json
GET /indexName/_search
{
  "query": {
    "match_all": {}
  },
  "sort": [
    {
      "FIELD": "desc"  // 排序字段、排序方式 ASC、DESC
    }
  ]
}
```
排序条件是一个数组，可以写多个排序条件。

按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推。

## 2.2 分页

Elasticsearch 默认情况下只返回 top 10 的数据。如果需要查询更多数据，就需要修改分页参数。Elasticsearch 中通过修改 `from` 和 `size` 参数来控制要返回的分页结果：

- **from**：从第几个文档开始  
- **size**：总共查询几个文档  

类似于 MySQL 中的 `LIMIT ?, ?`。

### 2.2.1 基本的分页

分页的基本语法如下：

```json
GET /hotel/_search
{
  "query": {
    "match_all": {}
  },
  "from": 0, // 分页开始的位置，默认为 0
  "size": 10, // 期望获取的文档总数
  "sort": [
    {"price": "asc"}
  ]
}
```

### 2.2.2 深度分页问题
如果要查询 990~1000 的数据，查询逻辑如下：
```json
GET /hotel/_search
{
  "query": {
    "match_all": {}
  },
  "from": 990, // 分页开始的位置，默认为 0
  "size": 10, // 期望获取的文档总数
  "sort": [
    {"price": "asc"}
  ]
}
```

## 2.2.3 小结

分页查询的常见实现方案以及优缺点：

### 1. `from + size`

- **优点**：支持随机翻页  
- **缺点**：存在深度分页问题，默认查询上限（`from + size`）是 10000  
- **场景**：适用于百度、京东、谷歌、淘宝等需要随机翻页的搜索场景  

### 2. `search_after`

- **优点**：没有查询上限（单次查询的 `size` 不超过 10000）  
- **缺点**：只能向后逐页查询，不支持随机翻页  
- **场景**：适用于没有随机翻页需求的搜索，例如手机向下滚动翻页  

### 3. `scroll`

- **优点**：没有查询上限（单次查询的 `size` 不超过 10000）  
- **缺点**：会有额外的内存消耗，并且搜索结果是非实时的  
- **场景**：适用于海量数据的获取和迁移。从 Elasticsearch 7.1 开始不推荐使用，建议使用 `search_after` 方案
